#  最短Hamilton路径

## 题意：带权无向图无重复走一遍的最短路径

一张n个点的带权无向图，从起点0出发到达终点n-1的最短 最短Hamilton路径。

最短Hamilton路径：从0到n-1每个点经过一次。

## 做法：dp

二维数组记录状态，状态为：经过点点集-当前终点。则转移方程为：

```c++
f[i][j]=min(f[i][j],f[i^(1<<j)][k]+weight[k][j]
```

其中i--经过点集，j--当前终点，weigth[k,j]--边权k-j

实现：1.枚举点集 2.枚举终点 3.枚举终点的上一点更新f

## 要点：位运算&二进制状态压缩

![image-20210329164459457](C:\Users\pengxin\AppData\Roaming\Typora\typora-user-images\image-20210329164459457.png)

1.用二进制位表示点集，其中某个位为1表示包含此点，如0101表示包含点1和点3（没有0）或者点0和2（有0）

   很明显此题有0

2.判断集合i是否包含点j，可以使用&运算符实现

## 代码：

```c++

int n;
const int N=20; //点最大值
const int M=1 << 20; //二进制表示集合，某位为一表示该集合包含某个数字，因为20个点所以应该设置21位，左移20位
int f[M][N]; //某个集合即通过的点集下 到达某个点时最小路径，一维点集 二维终点
int g[N][N]; //表示带权边
int main()
{
    std::cin>>n;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            std::cin>>g[i][j];
    std::memset(f,0x3f,sizeof f); //初始化无穷大
    f[1][0]=0;  //起点为1，权值为0
    for(int i=0;i< 1<<n ;i++){  //遍历点集
        for(int j=0;j<n;j++){  //遍历每个点
            if(i >> j & 1) //判断该点与当前点是否连通 即 是否有边k-j
               for(int k=0;k<n;k++){ //枚举所有到达j的点
                   if(i ^ (1 << j) >> k & 1){ //找到能到达j的上一个点k-----先去掉j点再判断
                       f[i][j]=std::min(f[i][j], f[i - (1 << j) ][k] + g[k][j] ) ; //更新一下取最小值
                   }
               }
        }
    }
    std::cout<<f[(1<<n)-1][n-1]<<'\n'; //总集为(1<<n)-1 ,终点为n-1
    return 0;
}

```

