# 关于取模运算的一点入门知识

嘛，既然有这个需求了那就讲吧

## 前言

这里要解决的终极问题是，**(a/b)%c=?**

这篇Tips面向学有余力且好奇心旺盛的同学

讲道理这块知识对你们来说暂时算是超前了

不过这篇Tips很简单的，不要害怕

## 取模运算

取模运算是你们刚学C++的时候接触到的第一个你们平时较少接触到的运算

其意义事实上就是**求余**，也就是计算除法的余数

例如说，`9%4`就是求9除以4下的余数，答案显然是1

到这一步都很好理解

## 取模运算带来哪些改变

是否有注意到，取模运算只能对整数使用？

也就是说，如果使用了取模的话，你所使用的数字集会**缩小到整数范围**内

更严格的讲，其实是**非负整数范围**内，因为负整数对非负整数取模事实上是等效于非负整数对非负整数取模的

此话怎讲？例如说`(-3)%4=(-3+4)%4=1%4=1`

> 在C++中你得到的结果是-3，这是因为C++中不会对余数进行修正
>
> 而事实上对C的取模运算下，数字的范围就已经被规定在[0,C-1]之间的整数了
>
> 所以在做题的时候，请注意**最后输出的取模的结果不能是负数**

也就是说，只要补正除数的倍数，被除数就可以是非负整数

而显然的，除数和结果都只可能是非负整数

于是在使用取模的情况下，你所使用的数字集会**缩小到非负整数范围**内

> 严格地讲，每一次对C取模之后的数字范围都会被规定在[0,C-1]之间的整数中
>
> 注意是**规定**

> 虽然可以做到，不过这里不讨论浮点数取模的情况，因为浮点数在取模运算中是被视为缩小了x倍的整数运算
>
> 例如说3.5%2.3（C++应该不能这么计算，这里事实上需要使用到math.h里的函数）事实上就是35%23的缩小版（当然结果也同比缩小了）

## 取模运算下的加减乘

这个相对来说比较简单，可以直接使用分步取余。理解起来也不难。

```
(a+b)%c=((a%c)+(b%c))%c
(a-b)%c=((a%c)-(b%c))%c
(a*b)%c=((a%c)*(b%c))%c
```

关于这个的证明如下：

```
首先假设a=a1+a2*c,b=b1+b2*c，其中a1和b1是a%c和b%c的结果
于是就有：
(a+b)%c=(a1+a2*c+b1+b2*c)%c=(a1+b1)%c+((a2+b2)*c)%c=(a1+b1)%c=((a%c)+(b%c))%c
(a-b)%c=(a1+a2*c-b1-b2*c)%c=(a1-b1)%c+((a2-b2)*c)%c=(a1-b1)%c=((a%c)-(b%c))%c
(a*b)%c=((a1+a2*c)*(b1+b2*c))%c=(a1*b1)%c+((a1*b2+a2*b1+a2*b2*c)*c)%c=(a1*b1)%c=((a%c)*(b%c))%c
证毕
```

事实上也很好理解，就是把a和b切割掉c的倍数的部分再进行运算

## 取模运算下的除法

接着讨论除法，你会发现使用上面分步取余的推导并没有办法推导出一个满意的式子

因为你无论怎么计算都无法把a2和b2去掉

于是就需要谋求新的运算方式了

于是有人会说，**除法不就是乘上它的倒数吗**？

理论上是的，不过问题就来了：

+ 在只有非负整数的运算体系中，一个数的倒数怎么计算？（因为分数并不是整数）

+ 乘上倒数这一步究竟在做什么？

我们先讨论后面这个问题

### 乘上倒数这一步究竟在做什么？

我们先去掉取模运算，回到你们最熟悉的实数运算

那么倒数就很好理解了，2的倒数就是0.5,3的倒数就是0.333...

那么，倒数有什么性质呢？倒数有一个重要的性质就是：**倒数乘上原数的积始终是一**

好的，讲到这一步，先给你们讲讲几个概念：

#### 运算

事实上运算体系不止一种，你们高中的时候接触到的就是实数运算体系。

可能会有人有接触到复数，然后发现复数的运算规则有些跟以前熟悉的那些是不通用的，那是因为复数的运算体系又跟实数的运算体系不一样（严格地讲是扩充了）。

你们大学的时候又接触到了矩阵，这又是一种新的计算单位，基于此单位的运算就是矩阵运算，这又跟实数运算不一样了。一个简单的例子就是在实数运算中可以使用的交换律，在矩阵运算中就用不了了。

那么，既然你们接触到矩阵了，那么矩阵逆元应该就听说过了吧？这个后面就会讲到了。

包括之后讲到的取模运算，这事实上又是一种运算体系了。

为什么这么说呢？因为我们默认**在C的取模运算体系中，每一次运算都需要对C取模**

例如说在8的取模运算体系中，5+5=2，而不是等于10（因为在这个体系里没有数字10）

那么区分运算体系的基准是什么呢？事实上只有一个：**参与运算的数字集不同**

例如说实数运算的数字集就是全体实数，矩阵运算的数字集就是全体矩阵，取模运算（假设对C取模）的数字集就是[0,C-1]中的整数集合

甚至你们可以自己搞个单位集合，做个自己的运算体系（不过没人用就是了）

#### 零元

每个完善运算都应该需要有一个零元。

零元的定义就是：

+ 任何其他单位加上零元之后不会有任何变化
+ 任何其他单位乘上零元之后会等于零元

在实数运算中零元就是数字0，在矩阵运算中零元就是全零矩阵，在取模运算中的零元显然也是0

#### 幺元

每个完善运算都应该需要有一个幺元。

幺元的定义就是：

+ 任何其他单位乘上幺元之后不会有任何变化

在实数运算中幺元就是数字1，在矩阵运算中幺元就是单位矩阵，在取模运算中的幺元显然也是1

#### 逆元

好了，终于到重点了。

首先，逆元不同于零元和幺元，逆元是针对某个数存在的。所以一般会称为**单位x在某个运算下的逆元**

那么逆元的定义是什么呢？其实很简单：

单位x * 单位x的逆元 = 幺元

于是你会发现，如果代入实数运算中的话，**单位x的逆元事实上就是数字x的倒数**

好的，那么我们就可以知道了，**倒数的本质就是逆元，乘上倒数这一步事实上就是在乘上它在这个运算下的逆元**

于是**除以单位x**事实上就等效于**乘上单位x的逆元**

包括矩阵的逆元事实上也就是其乘上对应的原矩阵的结果会等于单位矩阵。不过这个我就不展开讲了，具体请回头去看你们的线性代数课本

那么，对C取模的运算下呢？在对C取模的运算下，逆元事实上也是一个[0,C-1]的数字。

我举个例子吧：(16/4)%3=? 答案显然是1。但是如果不是(16/4)而是(1048576/512)呢，或者更大的呢？

于是就需要知道这里这个需要怎么计算了。

我们先假设已经知道了数字4（事实上是数字1，因为4%3=1）在对3取模的运算下的逆元为1

于是就有16/4=1/1=1*1=1

于是就可以得到(16/4)%3=1

也就是说，在我们知道某个数的逆元的情况下，我们可以直接把除以某个数换成乘以该数的逆元，于是前面的分步取余法又奏效了

那么到这里，我们的第一个问题就需要改描述了。

原问题是：在只有非负整数的运算体系中，一个数的倒数怎么计算？

现在的问题就是：**在对C取模的运算体系下，一个数的逆元怎么计算？**

### 如何计算逆元

首先，我们假设我们需要计算的逆元为，在对C取模的运算下，整数a的逆元

假设这个逆元为a'

这个我们需要分情况讨论：

#### C为质数的情况下

大多数时候你们会接触到的情况都是C为质数的情况

首先，我们可以得到这个式子：

```
(a*a')%C=1
```

事实上我们更经常用下面这种写法，这样的话对C取模就不是一个运算了，而是一个运算体系的约束条件：

```
a*a'=1 (mod C)
```

在这里有一个前提就是，假设我们能够知道下面这个二元一次等式的某组整数解(x,y)：

```
a*x+C*y=1
```

于是代入上面的式子，就有：

```
a*a'=a*x+C*y (mod C)
a*a'=a*x     (mod C)
a'=x         (mod C)
```

于是可以得知，上面的二元一次不等式的整数解中的x即为我们要找的逆元

那么问题便转换为如何求上面的二元一次等式了

在此之前我们需要先说一个算法：

##### 欧几里得算法

这个算法是用于求两个数的最大公约数的。虽然名字很洋气，不过这事实上就是你们高中学的辗转相除法。

设我们需要求整数a和整数b的最大公约数，结果记为GCD(a,b)，那么其求解过程就是：

```c++
int GCD(int a, int b)
{
    if(b == 0)
    	return a;
    else
    	return GCD(b, a%b);
}
```

事实上就是不断拿a%b的余数替换掉a，最终就会得到结果。

其时间复杂度为`O(logn)`，具体怎么得到的你们可以使用我之前给你们布置的时间复杂度的学习任务所学到的知识自己推敲一下，这个还是比较简单的

##### 扩展欧几里得算法

为了介绍扩展欧几里得，我们先介绍一下**贝祖定理**：

​      即如果a、b是整数，那么一定存在整数x、y使得ax+by=gcd(a,b)。

换句话说，如果ax+by=m有解，那么m一定是gcd(a,b)的若干倍。（可以来判断一个这样的式子有没有解）

这个算法就是用来给出如下方程的整数解：

```
a*x+b*y=1
```

当然，我这里讲的是这个算法的阉割版，完整的扩展欧几里得算法可以解决ax+by=c的等式

不过这里有个大前提就是a要跟b互质（也就是GCD(a,b)=1），否则该方程无整数解

先给出代码，这里假设该函数为EXGCD(a,b,x,y)，其中后面两个参数传的是引用，也就是用于做返回值的

```c++
void EXGCD(int a, int b, int &x, int &y)
{
    if(b == 0)
    {
        x = 1;
        y = 1;
        return;
    }
    int px, py;
    EXGCD(b, a%b, px, py);	//有没有觉得这里的前面两个跟GCD算法很像
    x = py;
    y = px - (a / b) * py;
}
```

现在解释一下这个算法：

首先，如果b=0的话，这里的a肯定是等于1的。因为在最开始的条件中要求a跟b互质，而参数a跟b的迭代事实上就是欧几里得算法的迭代（辗转相除法，对比一下上面GCD的代码），最终得到的结果肯定是1。于是此处为了让等式成立，x肯定等于1，而y就可以随便取值了

那么接着就是一般情况了。首先我们假设如下不等式已经解决：

```
bx'+(a%b)y'=1
```

这个其实就是个递归过程，我们之后就是利用递归解决的结果来还原我们要的结果。

于是等式事实上等价于：

```
由于a%b=a-(a/b)*b，故有： <=这一步请仔细思考为什么，然后再往下看
   bx'+(a%b)y'=1
=> bx'+(a-(a/b)*b)y'=1
=> bx'+ay'-(a/b)*by'=1
=> ay'+b[-(a/b)y'+x']=1
```

那么我们只需要令：

```
x=y'
y=-(a/b)y'+x'
```

就可以还原成我们需要的等式了（事实上就是根据递归的结果构造出我们需要的一个可行解）

![image-20201118145612096](C:\Users\pengxin\AppData\Roaming\Typora\typora-user-images\image-20201118145612096.png)

其实就是通过递归求解，欲求x1,y1;先求x2,y3；不断递归，最后xn=1,yn=0（此时b=0）；从而求出x1,y1。

##### 回到计算逆元的问题

于是，我们就可以使用扩展欧几里得算法来直接求逆元了。

由于C是质数，所以二元一次不等式肯定有解。

#### C不为质数的情况下

这个就复杂了。由于你们暂时没机会接触到这个，所以就不展开讲了

事实上简单地讲就是把单个C不为质数的式子拆成多个取模数为质数的式子，分开求解再合并

例如说，这里需要求x%15的结果

那么我们就可以求x%3和x%5的结果，然后使用**中国剩余定理**进行合并最终得到结果

至于中国剩余定理，这里就不讲了（刚入门接触这种算法不太好，建议看完并理解上面那些东西并把周赛打到黄名再去看吧）。原理类似于秦王暗点兵。

## 总结

至此，(a/b)%c的问题就算是解决了，虽然还留了个c不为质数的情况下的坑，不过这不重要

事实上有没有发现，这里面所有的运算都只会涉及到**非负整数**（即使出现负数也需要立刻修正，例如在对4取模的情况下，-1就需要修正为3）

这个事实上就是数论所讨论的数据集，而上面的资料，事实上就相当于数论入门了（虽然十分基础易懂）

至于hdu2239这道题，更多涉及到的是组合数学那块的知识，这个就不再展开讲了。

毕竟你们刚开始接触ACM，做事情最好是**循序渐进**比较好

当然，数论这一块你们还是是时候需要掌握了，至少上面那些得看懂吧？

至于为什么出这道题呢？我们当然不会无缘无故出这么难的题目的。那么这个就涉及到管理组的机密了。

另，上面那些可能有部分讲的比较粗糙（因为实在是太基础了，可能会无意间漏掉一些重要的东西），所以之后如果对上面的东西有哪一点看不懂的，可以私聊找我。当然我不会立刻回答，而是搜集你们不懂的点，把这篇文章（算是文章吧）尽可能完善。

完毕，祝大家刷题愉快。